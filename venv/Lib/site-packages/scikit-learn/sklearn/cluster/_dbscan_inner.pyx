# Fast inner loop for DBSCAN.
# Author: Lars Buitinck
# License: 3-clause BSD
#
# cython: boundscheck=False, wraparound=False

cimport cython
from libcpp.vector cimport vector
cimport numpy as np
import numpy as np


# Work around Cython bug: C++ exceptions are not caught unless thrown within
# a cdef function with an "except +" declaration.
cdef inline void push(vector[np.npy_intp] &stack, np.npy_intp i) except +:
    stack.push_back(i)

detectedCount = 0
def hasPerson(person, dc, index, is_detected):
    print('hasPerson : {}'.format(index))
    global detectedCount

    if is_detected[index] == -1:
        detectedCount += 1
        if person >= dc:
            is_detected[index] = 1
        else:
            is_detected[index] = 0

    return person >= dc


def removeNoise(nb_array, item):
    print('Remove item {}'.format(item))
    for i in range(len(nb_array)):
        nb_array[i] = nb_array[i][nb_array[i] != item]


def deep_dbscan_inner(np.ndarray[np.uint8_t, ndim=1, mode='c'] is_core,
                 np.ndarray[object, ndim=1] neighborhoods,
                 np.ndarray[np.npy_intp, ndim=1, mode='c'] labels,
                 np.ndarray[np.npy_intp, ndim=1, mode='c'] ori_X,
                 dc=0, min_samples=1):
    cdef np.npy_intp i, label_num = 0, v
    cdef np.ndarray[np.npy_intp, ndim=1] neighb
    cdef vector[np.npy_intp] stack

    # print('dc : {}, min_samples : {}'.format(dc, min_samples))
    ## 1 : person, 0 : not person, -1 : not detected
    is_detected = np.full(ori_X.shape[0], -1, dtype=np.intp)

    for i in range(labels.shape[0]):
        if labels[i] != -1 or not is_core[i]:
            continue

        # if not hasPerson(ori_X[i], dc, i):
        #     labels[i] = -2
        #     is_core[i] = 0
        #     continue

        # Depth-first search starting from i, ending at the non-core points.
        # This is very similar to the classic algorithm for computing connected
        # components, the difference being that we label non-core points as
        # part of a cluster (component), but don't expand their neighborhoods.
        isUpdatedLables = False
        while True:
            if labels[i] == -1 and is_core[i] and len(neighborhoods[i]) > min_samples:
                if hasPerson(ori_X[i], dc, i, is_detected):
                    neighb = neighborhoods[i]
                    detected = []
                    for j in range(neighb.shape[0]):
                        v = neighb[j]
                        if hasPerson(ori_X[v], dc, v, is_detected):
                            detected.append(v)
                        else:
                            labels[v] = -2
                            is_core[v] = 0
                            removeNoise(neighborhoods, v)

                    # min_samples 조건을 만족하면 클러스터 확장
                    if len(detected) >= min_samples:
                        labels[i] = label_num
                        for j in range(len(detected)):
                            index = detected[j]
                            if labels[index] == -1:
                                if is_core[index]:
                                    push(stack, index)
                                    isUpdatedLables = True
                                else:
                                    labels[index] = label_num
                    # core 아니면 label 할당
                    else :
                        labels[i] = label_num
                # Not Person
                else:
                    is_core[i] = 0
                    labels[i] = -2
                    removeNoise(neighborhoods, v)

            elif labels[i] == -1:
                labels[i] = label_num

            if stack.size() == 0:
                break
            i = stack.back()
            stack.pop_back()

        if isUpdatedLables:
            label_num += 1

    print('dbscan_inner detectedCount : {}'.format(detectedCount))

def dbscan_inner(np.ndarray[np.uint8_t, ndim=1, mode='c'] is_core,
                 np.ndarray[object, ndim=1] neighborhoods,
                 np.ndarray[np.npy_intp, ndim=1, mode='c'] labels):
    cdef np.npy_intp i, label_num = 0, v
    cdef np.ndarray[np.npy_intp, ndim=1] neighb
    cdef vector[np.npy_intp] stack

    for i in range(labels.shape[0]):
        if labels[i] != -1 or not is_core[i]:
            continue

        # Depth-first search starting from i, ending at the non-core points.
        # This is very similar to the classic algorithm for computing connected
        # components, the difference being that we label non-core points as
        # part of a cluster (component), but don't expand their neighborhoods.
        while True:
            if labels[i] == -1:
                labels[i] = label_num
                if is_core[i]:
                    neighb = neighborhoods[i]
                    for i in range(neighb.shape[0]):
                        v = neighb[i]
                        if labels[v] == -1:
                            push(stack, v)

            if stack.size() == 0:
                break
            i = stack.back()
            stack.pop_back()

        label_num += 1
